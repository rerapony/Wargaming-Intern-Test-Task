#### Решение

##### Task 1

Изначальное решение: 
Pros: по коду сразу понятно, что происходит; 
Cons: может быть медленнее для некоторых (старых версиях) компиляторов, чем решение с битовой логической операцией &. Однако оптимизация решает.

Решение с использованием битовой операции &: 
Pros: должно быть быстрее, т.к. проверяется только последний бит числа и логическая операция работает быстрее быть быстрее взятия модуля; 
Cons: менее понятно, что происходит.

Современные компиляторы достаточно хорошо оптимизируют код, чтобы решение с модулем не проигрывало решению с битовой операцией, поэтому существенных различий нет.

##### Task 2

Два варианта:

- на базе односвязного списка (добавление О(1), удаление О(1)). Нельзя удалять из середины.
- на базе массива (добавление О(1), удаление О(n)), но ограничен по размеру (иначе в худшем случае добавление O(n)). Может использовать больше памяти чем требуется/не вместить новые элементы, если память переполнится. Можно удалять из середины.



##### Task 3

Кажется, что в любом случае мы должны выбирать QuickSort, но эта сортировка дает O(N^2) в худшем случае и плохо ведет себя в случае отсортированного массива (и по возрастанию, и по убыванию).

Поэтому если у нас существенных требований к памяти, то можно выбрать MergeSort.

MergeSort дает O(logN) сложость во всех случаях, но занимает много места (O(n)). Также её можно распараллелить.

Обзор других алгоритмов сортировки:

 - HeapSort дает O(logN) и занимает всего O(1) памяти, но не стабилен, MergeSort имеет меньшую константу (быстрее).
- Insertion Sort дает O(n) для отсортированного массива, но O(n^2)  - в худшем случае (для отсортированного в обратном порядке).

- BucketSort - дает O(n) в среднем, но O(n^2) в худшем, и необходимо знать природу входящего массива.